#!/bin/bash

declare portFile initFile ttystate script waitFile tmpPipe
declare -i pid port streamPid continue pipePid
declare -a args signals sttyOptions


# The name of the file which will contain the port number
name="fury"

# The TTY settings to use for terminal input
sttyOptions=(intr undef -echo icanon raw opost)


baseDir="${XDG_RUNTIME_DIR:-$HOME/.local/state}/$name"
portFile="$baseDir/port"
initFile="$baseDir/init"
waitFile="$baseDir/wait"
failFile="$baseDir/fail"
script="$0"
continue=1

# The set of signals which should be captured and forwarded to the JVM process
signals=(INT WINCH TERM USR1 USR2)

pid=$$
args=("$@")

recovery() {
  test -t 0 && stty "$ttystate"
  printf "The daemon process failed to start.\n" >&2
  printf "Remove the file %s before trying again.\n" "$failFile" >&2
  exit 1
}

abort() {
  touch "$failFile"
  printf '' > "$waitFile"
  rm -f "$waitFile" "$initFile"
}

launch() {
  mkfifo "$waitFile" 2> /dev/null && (nohup wrath -x > /home/propensive/work/exoskeleton/out.log 2>&1 || abort) &
  flock "$initFile" sh -c "test -f \"$portFile\" || cat \"$waitFile\"" > /dev/null 2>&1 || abort
  rm -f "$initFile"
}

handle() {
  case "$1" in
    TERM) continue=0 ;;
  esac
  printf "signal %s\nprocess %s\n" "$1" "$pid" | nc -q 1 localhost $port
}

connect() {
  printf "process %s\n" "$pid"
  printf "script %s\n" "$script"
  printf "work %s\n" "$(pwd)"

  for arg in "${args[@]}"
  do printf "arg\n    %s\n" "$arg"
  done

  while IFS= read -r -d $'\0' variable
  do printf "env\n    %s\n" "$variable"
  done < <(env -0)

  test -t 0 && printf "input term\n" || printf "input pipe\n"
  printf "##\n"
  exec cat
}

test -t 0 && ttystate="$(stty -g)"
mkdir -p "$baseDir"
test -t 0 && stty "${sttyOptions[@]}" > /dev/null 2>&1
test -f "$failFile" && recovery
flock -n "$portFile" rm "$portFile"
test -f "$portFile" || launch
test -f "$failFile" && recovery
port=$(cat "$portFile")

tmpPipe="$(mktemp -u)"
mkfifo -m 600 "$tmpPipe"
exec 3<> "$tmpPipe"
rm "$tmpPipe"
connect <&0 >&3 &
streamPid=$!
nc -q 1 localhost $port <&3 &
pipePid=$!

for signal in "${signals[@]}"
do trap "handle $signal" "$signal"
done

while [ $continue = 1 ]
do
  wait $pipePid
  ps $pipePid > /dev/null || continue=0
done

test -t 0 && stty "$ttystate" && kill $streamPid

exit 0